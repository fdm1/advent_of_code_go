package main

import (
  "fmt"
  "strings"
  "time"

  "github.com/fdm1/advent_of_code_go/pkg/advent_of_code"
  "github.com/fdm1/advent_of_code_go/pkg/aoc_utils"
)

func main() {
  yearNeeded := true
  validYears := ValidYears()
  var year string
  for yearNeeded {
    fmt.Printf("Year: ")
    fmt.Scanln(&year)
    if aoc_utils.StringSliceContainsChar(validYears, year) {
      yearNeeded = false
    } else {
      fmt.Printf("Year %v is not valid. Valid choices are %v\n\n", year, validYears)
    }
  }

  dayNeeded := true
  fmt.Printf("Going to get days for %v", year)
  validDays := ValidDays(year)
  var day string
  for dayNeeded {
    fmt.Printf("Day: ")
    fmt.Scanln(&day)
    if aoc_utils.StringSliceContainsChar(validDays, day) {
      dayNeeded = false
    } else {
      fmt.Printf("Day %v is not valid. Valid choices are %v\n\n", day, validDays)
    }
  }

  partNeeded := true
  part := ""
  validParts := []string{"1", "2"}
  for partNeeded {
    fmt.Printf("Part: ")
    var part string
    fmt.Scanln(&part)
    if aoc_utils.StringSliceContainsChar(validParts, part) {
      partNeeded = false
    } else {
      fmt.Printf("Part %v is not valid. Valid choices are %v\n\n", part, validParts)
    }
  }

  function := advent_of_code.PuzzleMap(year, day, part)
  start := time.Now()
  result := function(true)
  duration := time.Since(start)
  fmt.Printf("Result: %v\n", result)
  fmt.Printf("Ran in %v\n", duration)
}

func ValidYears() []string {
  resultMap := map[string]bool{}
  for key, _ := range advent_of_code.PuzzleFunctions() {
    resultMap[strings.Split(key, "-")[0]] = true
  }
  result := []string{}
  for key, _ := range resultMap {
    result = append(result, key)
  }
  return result
}

func ValidDays(year string) []string {
  resultMap := map[string]bool{}
  fmt.Println(year)
  for key, _ := range advent_of_code.PuzzleFunctions() {
    if year == strings.Split(key, "-")[0] {
      fmt.Println(key)
      resultMap[strings.Split(key, "-")[1]] = true
    }
  }
  result := []string{}
  for key, _ := range resultMap {
    result = append(result, key)
  }
  return result
}
